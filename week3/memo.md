- git 처럼 관리하는것
- libostree가 기본적으로 내장은 되어있다
- 컨테이너의 장점? 오버레이 컨테이너의 장점?
    - 이거 실제로는 어떻게 동작하는데?
    - 컨테이너는 커널 빠진 OS네? 그럼 OS를 선언만 해주면 되는거 아니야? -> 여기서 시작됨! 오 나도 이해함
- 도커만 쓰면, 앞에꺼 캐시 그대로 가져와서 같은데? 도커 캐시랑 ostree를 쓰는 bootc랑 뭔차이라고 생각해?
    - 이걸 libostree를 가져감.
    - 컨테이너의 장점은 딱 os까지만!
    - 그리고 파일시스템의 변경사항 등을 libostree정도만 가져간다!
    - 즉, 컨테이너 모든 변경사항을 바꿀필요없이, libostree가 변경사항정도만 시스템의 변경사항을 적용시켜줄 수 있음!
- 근데 이렇게 파일시스템을 해시로만들어서 관리하던 NIX OS 가 이미 있었따.
    - 근데 얘는 러닝커브가 ㅈㄴ높음
- OCI를 좀 봤으면 좋겠다!
    - OCI는 하나의 규격을 맞추는 레지스트리임.
    - OCI의 최소 표준만 맞춘다면,도커를 실제로 땡겨왔을때
- podman은 bootless? 가 가능하다고 이게 무슨말이지?
    - /usr 과 관련있는것같은데..
    - 결국 컨테이너가 루트권한을 가져가는게 말이 안된다고?
- bootc는 컨테이너가 아니기에, systemctl을 하는 의미가없다는데, 이게 무슨 의미일까?
- 빌더를 좀 더 알아보면 좋을 것 같다!
- OCI 먼저 보고, Podman을 이해해보라.
- 종석님꺼, 천수님꺼 리뷰 ㄱㄱ
- libostree기반의 OS여야만 podman 으로 bootc부팅이 가능함!
- AWS에서 쓰고싶다면..
    - iso로 만들었다? -> AMI
    - podman으로 빌드했다? -> ECR
- s3 on-demand  container loading in AWS Lambda 논문 읽어봐
    - aws lambda 10gb image load ?
    - 딥러닝때문에 이거 이미지 용량이 ㅈㄴ 커졌어 !
    - 그래서 VM , 컨테이너 등 다양한 위치에서 캐싱을 ㅈㄴ 하게 되었다!
    - 이게 OCI를 어떻게 이해하는지 알 수 있고, 이게 어떻게 도커가 작동하는지 알 수 있다.
- 결론, 꼭 도큐먼트를 읽어요~

- 다음 과제는... bootc 업데이트 및 롤백을 수행해보는것을 목표로 해보자!
    - 이미지 올리고
    - 업데이트 하고
    - 롤백 해보고
    - os임에도, 어떻게 이게 가능한지 알아보자!
    - OCI는 무조건 보고, 정리하라! OCI이해없이 bootc의 필요를 덜 느낄 수 있다!(이거 모르면 bootc의 장점을 알 수 없다!)
    - 나는, 추가로 네트워크 환경이 많으니, 진짜로 사용할거라 생각하면서 네트워크 설정을 처음부터 고정으로 해둬봐!
        - 그리고 하버도 다운받아서, 이미지를 올리고 업데이트해보고 해봐! 같이 써봐!
        - 도커가 어떻게 다운받고, 로드하는지 한번 봐바!

- 추가 과제
    - https://blog.sionic.ai/enterprise-update-docker-strategy
    - 이거 한번 따라해봐~ 이거 어떻게 돌아가는지 한번 이해해봐~
    - 여기서 잡아야할 포인트가 뭘까?
    - 이미지를 저장해본다 허브같은곳에! 그리고 이걸 불러올건데, libostree도 껴있잖아? docker뿐만아니라!
    - libostree기반의 이미지를 가져올때, docker가 가져오는 방식과, libsotree방식을 불러오는것의 차이를 알아보면 좋다!
